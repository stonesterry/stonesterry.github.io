{"meta":{"title":"stonesterry","subtitle":"linux/filesystem","description":"filesystem","author":"stonesterry","url":"http://stonesterry.cn","root":"/"},"pages":[{"title":"c_container_of","date":"2020-04-29T14:21:23.000Z","updated":"2020-04-29T14:21:23.953Z","comments":true,"path":"c-container-of/index.html","permalink":"http://stonesterry.cn/c-container-of/index.html","excerpt":"","text":""},{"title":"huozhe","date":"2020-04-29T15:02:41.000Z","updated":"2020-04-29T15:02:41.273Z","comments":true,"path":"huozhe/index.html","permalink":"http://stonesterry.cn/huozhe/index.html","excerpt":"","text":""},{"title":"c_memory","date":"2020-04-30T13:43:17.000Z","updated":"2020-04-30T13:43:17.864Z","comments":true,"path":"c-memory/index.html","permalink":"http://stonesterry.cn/c-memory/index.html","excerpt":"","text":""}],"posts":[{"title":"c内存管理","slug":"c-memory","date":"2020-04-30T12:58:23.000Z","updated":"2020-04-30T15:01:59.928Z","comments":true,"path":"2020/04/30/c-memory/","link":"","permalink":"http://stonesterry.cn/2020/04/30/c-memory/","excerpt":"对c语言中内存使用管理进行分析","text":"对c语言中内存使用管理进行分析 参考《c语言深度剖析》&amp;《高质量c++/c编程指南》 1.内存常见错误及对策 (1)用malloc或new来申请内存，应该用if (p == NULL) 或if (p != NULL)进行防错处理。 (2)动态内存申请后，先统一初始化(内存的缺省初值不一定为0)。 (3)动态申请的内存，用完后需要释放，否则会造成内存泄漏。 (4)内存释放后，不能再对其继续使用。下面三种情况是内存释放后仍然对其使用了: 1234（1）程序中的对象调用关系过于复杂，实在难以搞清楚某个对象究竟是否已经释放了内存，此时应该重新设计数据结构，从根本上解决对象管理的混乱局面。（2）函数的 return语句写错了，注意不要返回指向“栈内存”的“指针”或者“引用”，因为该内存在函数体结束时被自动销毁。（3）使用 free或 delete释放了内存后，没有将指针设置为 NULL。导致产生“野指针”。 2.内存释放(1)free和delete 它们只是把指针所指的内存给释放掉，但并没有把指针本身干掉。指针p被 free以后其地址仍然不变（非 NULL），只是该地址对应的内存是垃圾，p成了“野指针”。如果此时不把 p设置为 NULL，会让人误以为 p是个合法的指针。 如以下示例: 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main()&#123; char *p = NULL; p = (char *)malloc(100 * sizeof(char)); strcpy(p, \"hello\"); printf(\"%s\\n\", p); printf(\"p addr=0x%p\\n\", p); free(p); if (p != NULL) &#123; printf(\"after free p, p is not null\\n\"); printf(\"p addr=0x%p\\n\", p); printf(\"%s\\n\", p); &#125; p = NULL; printf(\"p addr=0x%p\\n\", p); return 0; &#125; 运行结果 1234567hellop addr=0x0000000000AD13E0after free p, p is not nullp addr=0x0000000000AD13E0pq?p addr=0x0000000000000000 (2)动态内存不会自动释放 函数体内的局部变量在函数结束时自动消亡,但是函数体内申请的动态内存不会 12345678void func(void)&#123; char *p = NULL; p = (char *)malloc(100 * sizeof(char));&#125; 函数退出时,指针p会消亡,但是动态内存还在,即以后再申请内存时,这片内存是被占用的,如果再申请是申请不到这片内存的。 内存释放小结 (1)指针消亡了，并不表示它所指的内存会被自动释放。(2)内存被释放了,并不表示指针会消亡或者成了NULL指针(free或delete)。 3.指针参数传递内存地址123456789101112void GetMemory1(char *p, int num)&#123; p = (char *)malloc(sizeof(char) * num);&#125;void test1(void)&#123; char *str = NULL; GetMemory1(str, 100); printf(\"str addr=%p\\n\", str);//地址仍为0 strcpy(str, \"test\");//程序会崩溃 &#125; GetMemory1中。编译器总是要为函数的每个参数制作临时副本，指针参数p的副本是 _p，编译器使 _p = p。如果函数体内的程序修改了_p的内容，就导致参数p的内容作相应的修改。这就是指针可以用作输出参数的原因。在本例中，_p申请了新的内存，只是把_p所指的内存地址改变了，但是 p丝毫未变。所以函数GetMemory1并不能输出任何东西。事实上，每执行一次 Get Memory 就会泄露一块内存，因为没有用 free释放内存。 解决方法1:使用二级指针 如以下示例1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;void GetMemory(char **p, int num)&#123; printf(\"p addr=0x%p\\n\", p); printf(\"*p addr=0x%p\\n\", *p); printf(\"call malloc\\n\"); *p = (char *)malloc(sizeof(char) * num); printf(\"p addr=0x%p\\n\", p); printf(\"*p addr=0x%p\\n\", *p); &#125;int main()&#123; char *str = NULL; printf(\"&amp;str addr=0x%x\\n\", &amp;str); printf(\"str addr=0x%p\\n\", str); GetMemory(&amp;str, 20); printf(\"&amp;str addr=0x%x\\n\", &amp;str); printf(\"str addr=0x%p\\n\", str); return 0; &#125; 运行结果123456789&amp;str addr=0x62fe18str addr=0x0000000000000000p addr=0x000000000062FE18*p addr=0x0000000000000000call mallocp addr=0x000000000062FE18*p addr=0x0000000000BA1400&amp;str addr=0x62fe18str addr=0x0000000000BA1400 下图是对二级指针malloc前后的地址进行分析 解决方法2:用函数返回值来传递动态内存 1234567891011121314151617181920char *GetMemory2(char *p, int num)&#123; p = (char *)malloc(sizeof(char) * num); return p;&#125;void test2(void)&#123; char *str = NULL; str = GetMemory2(str, 100); printf(\"str addr=%p\\n\", str); strcpy(str, \"test\"); printf(\"%s\\n\", str); free(str); str = NULL;&#125;","categories":[],"tags":[{"name":"c基础知识","slug":"c基础知识","permalink":"http://stonesterry.cn/tags/c%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"活着","slug":"huozhe","date":"2020-04-29T14:59:11.000Z","updated":"2020-04-30T15:01:01.911Z","comments":true,"path":"2020/04/29/huozhe/","link":"","permalink":"http://stonesterry.cn/2020/04/29/huozhe/","excerpt":"阅读《活着》","text":"阅读《活着》 自序里面提到“人是为活着本身而活着的，而不是为了活着之外的任何事物所活着”,自己对这句话没有理解到，为什么不是为了活着之外的事物所活着呢？人生理想，金钱，权力等都可以是之外的事物，而如果我们不追求这些又有什么意义呢？即使是“采菊东篱下”，也是为了追求一种恬然的境界。 读完本书之后觉得与三观卖血相比,确实显得很悲情，生命渺小，人生无常。平时需要多锻炼身体，珍惜眼前人。 “我看到广阔的土地袒露着结实的胸膛，那是召唤的姿态，就像女人召唤着她们的儿女，土地召唤黑夜降临”，让我想起小时候的一些场景，夏天里，黄昏时刻，黑夜即将到来，乡下的田野路上，蟋蟀声， 蛙叫声等声叫已经此起彼伏了，农忙人也停止了在田里的耕种，开始相互寒暄今日的劳作情况。有的人把牛拉到河边让其洗澡，或给它们喂草以犒劳其辛勤劳动。远处屋顶的炊烟已袅袅升起，远处传来呼喊声，呼喊着还在田埂上追逐跑跳的孩童回家吃饭。渐渐地，黑夜彻底降临，天上的月亮却显得格外明亮，远处人家的灯也亮了起来……","categories":[],"tags":[{"name":"文学阅读","slug":"文学阅读","permalink":"http://stonesterry.cn/tags/%E6%96%87%E5%AD%A6%E9%98%85%E8%AF%BB/"}]},{"title":"container_of","slug":"c-container-of","date":"2020-04-29T13:04:27.000Z","updated":"2020-04-30T15:00:10.443Z","comments":true,"path":"2020/04/29/c-container-of/","link":"","permalink":"http://stonesterry.cn/2020/04/29/c-container-of/","excerpt":"对linux中container_of这个宏进行分析","text":"对linux中container_of这个宏进行分析 作用通过结构体变量的某个成员的地址来获取整个结构体的首地址 解析以linux4.19的container_of为例 123456789101112131415/** * container_of - cast a member of a structure out to the containing structure * @ptr: the pointer to the member. * @type: the type of the container struct this is embedded in. * @member: the name of the member within the struct. * */#define container_of(ptr, type, member) (&#123; \\ void *__mptr = (void *)(ptr); \\ BUILD_BUG_ON_MSG(!__same_type(*(ptr), ((type *)0)-&gt;member) &amp;&amp; \\ !__same_type(*(ptr), void), \\ \"pointer type mismatch in container_of()\"); \\ ((type *)(__mptr - offsetof(type, member))); &#125;)#define offsetof(TYPE, MEMBER) ((size_t)&amp;((TYPE *)0)-&gt;MEMBER) ptr:指向结构体member成员的指针type:member成员所在结构体的数据类型member:结构体成员为member的变量 首先定义了一个(void *)的指针__mptr，指向ptr BUILD_BUG_ON_MSG的作用是做防御性的判断，判断类型是否一致，若不一致则会报错 ((type *)(__mptr - offsetof(type, member)))这是整个container_of的核心,即得到结构体的首地址，对offsetof(type, member)进行展开123456#define offsetof(TYPE, MEMBER) ((size_t)&amp;((TYPE *)0)-&gt;MEMBER)&amp;((TYPE *)0)-&gt;MEMBER:将0地址转换为TYPE型的，然后取出其MEMBER成员的地址。换句话说得到MEMBER成员相对于结构体首地址的相对偏移量，再用__mptr减去这个相对偏移地址即得到结构体的首地址了。需要说明一点的是__mptr变量的结构类型为(void *)是有特殊含义的,我们知道指针变量进行加减运算时，实际上加减n*sizeof(指针类型)。如int *p;p++实际上等于p+sizeof(int) 测试 源码1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct test_container_of&#123; char a; int b; double c;&#125;tag_test_container_of;int main()&#123; tag_test_container_of test_var; printf(\"test_var addr= 0x%p\\n\", &amp;test_var); printf(\"test_var.c addr=0x%p\\n\", &amp;test_var.c); printf(\"offset c in tag_test_container_of is %d\\n\", (long long)(&amp;(((tag_test_container_of*)0)-&gt;c))); printf(\"addr test_var.c - offset c in tag_test_container_of = 0x%x\\n\", (&amp;test_var.c) - (int)(&amp;(((tag_test_container_of*)0)-&gt;c))); printf(\"addr test_var.c - offset c in tag_test_container_of = 0x%x\\n\", (void *)(&amp;test_var.c) - (char)(&amp;(((tag_test_container_of*)0)-&gt;c))); return 0;&#125; 结果12345678test_var addr= 0x000000000062FE10test_var.c addr=0x000000000062FE18offset c in tag_test_container_of is 8addr test_var.c - offset c in tag_test_container_of(type=int) = 0x62fdd8 (0x000000000062FE18-8*sizeof(int))addr test_var.c - offset c in tag_test_container_of(type=char) = 0x62fe10 (0x000000000062FE18-8*sizeof(char))/* 0x62fdd8 = (0x000000000062FE18-8*sizeof(int)) *//* 0x62fe10 = (0x000000000062FE18-8*sizeof(char)) */","categories":[],"tags":[{"name":"c基础知识","slug":"c基础知识","permalink":"http://stonesterry.cn/tags/c%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]}],"categories":[],"tags":[{"name":"c基础知识","slug":"c基础知识","permalink":"http://stonesterry.cn/tags/c%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"文学阅读","slug":"文学阅读","permalink":"http://stonesterry.cn/tags/%E6%96%87%E5%AD%A6%E9%98%85%E8%AF%BB/"}]}